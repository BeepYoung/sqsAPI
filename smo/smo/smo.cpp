#ifndef SMO_H
#define SMO_H

//ДП — диспетчер постановки заявок в очередь.
//
//ДВ — диспетчер выбора заявок из очереди.
//ДП — диспетчер постановки, выполняет две задачи :
//
//-отправляет заявку на обслуживание или в буферную память в случае отсутствия свободных приборов;
//
//-организует отказ или выбивание заявки из БП, если в буфере не осталось свободных мест.
//
//ДВ — диспетчер выбора, выполняет две задачи :
//
//-выбирает прибор, на котором обслуживает заявку;
//
//-выбирает заявку из БП, если она там есть.
//
//5. ИБ ИЗ1 ПЗ2 Д10З1 Д10О1 Д2П1 Д2Б5 ОР1 ОД2
//
//1.Источник бесконечный N
//2.пуассоновский для бесконечных
//3.Закон распеделения равномерный
//4.Дисциплины буферизации.Д1ОЗ1 — по кольцу; K
//Д2П1 Д2Б5 ОР1 ОД2
//5.Д1ОО1 — отказ под указателем.
//6.Д2П1 — приоритет по номеру прибора.
//7.Д2Б5 — приоритет по номеру источника, заявки в пакете.
//8.ОР1 — сводная таблица результатов; 3.2.Отражение результатов
//после сбора статистики ОР1 - ОР2(автоматический режим).
//7.ОД2 — формализованная схема модели, текущее состояние;
//Динамическое отражение результатов


#include <iostream>
#include <string>
#include <memory>
#include <utility>

//#include "Buffer.h"
#include "Sqs.h"
#include "Request.h"
#include "Source.h"

template<typename T>
void printVector(std::vector<T> data) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i) << "\n";
	}
}

template<typename T>
void printVector2(std::vector<T> data, std::vector<T> data1) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i) << "\t" << data1.at(i) << "\n";
	}
}

void printVector3(std::vector<Request> data, std::vector<Request> data1) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i).getGenerationTime() << "\t\t" << data1.at(i).getGenerationTime() << "\n";
	}
}

int main() {
	std::shared_ptr<Source> src(new Source(14, 14));
	std::pair<int, int> somePair;

	//Request req (float(15.1), std::pair<int, int>(3, 15));
	typedef std::shared_ptr<Source> Source_t;

	std::vector<Source_t> sources;
	for (int i = 0; i < 15; i++) {
		sources.push_back(Source_t(new Source(rand() % 5, i)));
	}
	
	Source_t src1(new Source(1, 1));// лямбда = 1
	Source_t src2(new Source(50, 2));//lyambda = 50
	std::vector<Request> rec1;
	std::vector<Request> rec2;

	
	//Мы генерируем время на всех src, потом смотрим какое из них получилось самое маленькое
	//Берем его в обработку(забираем заявку с таким временем), генерим на нем же новое t
	//опять смотрим самое маленькое и т.д. еееееееее рок
	//Это делает диспетчер постановки в буфер
	
	// тактом работы СМО является генерация новой заявки. В ээтот момент производятся
	//некоторые операции во всех ее частях:
	//		1.Обработка попадания в буфер
	//		2.Обработка выбора на прибор
	//		
	//
	//
	//
	//
	//
	//
	for (int i = 0; i < 50; i++) {

		rec1.push_back(src1->generate());
		rec2.push_back(src2->generate());
	}

	printVector3(rec1, rec2);

//	std::cout << req.getGenerationTime() << "\t" << req.getNumber().first << "\t" << req.getNumber().second << "\n";
	/*for (int i = 0; i < 50; i++) {
		Request req = src->generate();
		std::cout << req.getGenerationTime() << "\t" << req.getNumber().first << "\t" << req.getNumber().second << "\n";
	}
*/
	if (FULL == 1) {
		std::cout << "Yes\n";
	}
	else {
		std::cout << FULL<<"\n";
	}

	std::cout << "Hey!\n";
	system("pause");
}

#endif // !SMO_H

//=================================TECH
//1.Источник
//1.1.Генерирует время появления заявки
//2.Буфер
//2.1.Хранит инфу про время приема
//2.2.Полон ?
//2.3.Пуст ?
//2.4.Помещает / отдает элементы
//3.Прибор обрабатывает заявки
//3.1.Генерирует время освобождения прибора
//
//4.Диспетчер распределяет заявки(на вход и выход из буфера)
//4.1.Диспетчер приема
//4.1.1.Ложит заявки в буфер
//4.2.Диспетчер выборки
//4.2.1.Забирает заявки из буфера
//
//5.Заявка живет своей жизнью
