#ifndef SMO_H
#define SMO_H

//ДП — диспетчер постановки заявок в очередь.
//
//ДВ — диспетчер выбора заявок из очереди.
//ДП — диспетчер постановки, выполняет две задачи :
//
//-отправляет заявку на обслуживание или в буферную память в случае отсутствия свободных приборов;
//
//-организует отказ или выбивание заявки из БП, если в буфере не осталось свободных мест.
//
//ДВ — диспетчер выбора, выполняет две задачи :
//
//-выбирает прибор, на котором обслуживает заявку;
//
//-выбирает заявку из БП, если она там есть.
//
//5. ИБ ИЗ1 ПЗ2 Д10З1 Д10О1 Д2П1 Д2Б5 ОР1 ОД2
//
//1.Источник бесконечный N
//2.пуассоновский для бесконечных
//3.Закон распеделения равномерный
//4.Дисциплины буферизации.Д1ОЗ1 — по кольцу; K
//Д2П1 Д2Б5 ОР1 ОД2
//5.Д1ОО1 — отказ под указателем.
//6.Д2П1 — приоритет по номеру прибора.
//7.Д2Б5 — приоритет по номеру источника, заявки в пакете.
//8.ОР1 — сводная таблица результатов; 3.2.Отражение результатов
//после сбора статистики ОР1 - ОР2(автоматический режим).
//7.ОД2 — формализованная схема модели, текущее состояние;
//Динамическое отражение результатов


#include <iostream>
#include <string>
#include <memory>
#include <utility>

//#include "Buffer.h"
#include "Sqs.h"
#include "Request.h"
#include "Source.h"
#include "GettingManager.h"

template<typename T>
void printVector(std::vector<T> data) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i) << "\n";
	}
}

template<typename T>
void printVector2(std::vector<T> data, std::vector<T> data1) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i) << "\t" << data1.at(i) << "\n";
	}
}

void printVector3(std::vector<Request> data, std::vector<Request> data1) {
	for (size_t i = 0; i < data.size(); i++) {
		std::cout << data.at(i).getGenerationTime() << "\t\t" << data1.at(i).getGenerationTime() << "\n";
	}
}

int main() {

	Sqs sqs(5, 5, 1, 10);
	sqs.work();


	//Мы генерируем время на всех src, потом смотрим какое из них получилось самое маленькое
	//Берем его в обработку(забираем заявку с таким временем), генерим на нем же новое t
	//опять смотрим самое маленькое и т.д.
	//Это делает диспетчер постановки в буфер
	
	// тактом работы СМО является генерация новой заявки. В ээтот момент производятся
	//некоторые операции во всех ее частях:
	//		1.Обработка попадания в буфер
	//		2.Обработка выбора на прибор
	//		

	system("pause");
}

#endif // !SMO_H

//=================================TECH
//1.Источник
//1.1.Генерирует время появления заявки
//2.Буфер
//2.1.Хранит инфу про время приема
//2.2.Полон ?
//2.3.Пуст ?
//2.4.Помещает / отдает элементы
//3.Прибор обрабатывает заявки
//3.1.Генерирует время освобождения прибора
//
//4.Диспетчер распределяет заявки(на вход и выход из буфера)
//4.1.Диспетчер приема
//4.1.1.Ложит заявки в буфер
//4.2.Диспетчер выборки
//4.2.1.Забирает заявки из буфера
//
//5.Заявка живет своей жизнью
